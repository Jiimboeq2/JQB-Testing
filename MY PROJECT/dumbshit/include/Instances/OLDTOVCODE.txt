;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; TOV NAMED CODING ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;script to Automate Chamber Warden in Stratum 
function Warden()
{
	variable bool IconsDead=FALSE
	relay "other ${RI_Var_String_RelayGroup}" -noredirect "OgreFollowOb:SetFollower[all,off]"
	relay "other ${RI_Var_String_RelayGroup}" -noredirect OgreBotAtom a_QueueCommand DoNotMove
	echo running warden
	;set RedText var
	IncomingText:Set["The Chamber Warden is no longer restrained!"]
	;stop ogre from reapplying all hate buffs
	OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_buffs TRUE
	wait 5
	while ${CustomActor[Warden,radius,75](exists)} && !${CustomActor[Warden,radius,75].IsDead} && ${Start} 
	{
		;now remove hate buffs and move everyone to there respective positions and lock there
		if ${Me.Archetype.Equal[fighter]}
		{
			echo im a fighter
			Me.Maintained[Shoulder the Burden]:Cancel
			Me.Maintained[Moderate IV]:Cancel
			Me.Maintained[Improved Moderation]:Cancel
			echo target warden
			target Warden
			wait 200 ${Actor[Warden].IsAggro}
			OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_combat TRUE
			OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_ca TRUE
			OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_namedca TRUE
			OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_rangedattack FALSE
			OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_meleeattack FALSE
			if ${Me.SubClass.Equal[guardian]}
			{
				if ${Me.Ability[Provoke IX].IsReady}
					Me.Ability[Provoke IX]:Use
				if ${Me.Ability[Shout VII].IsReady}
					Me.Ability[Shout VII]:Use
			}
			if ${Me.AutoAttackOn}
			{
				eq2ex toggleautoattack
			}
			if ${Trigger}
			{
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_combat FALSE
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_ca FALSE
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_namedca FALS
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_rangedattack TRUE
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_meleeattack TRUE
				Trigger:Set[FALSE]
			}
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-18.613346,-224.574661,25.575129]}>2
				call Move -18.613346 -224.574661 25.575129 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			if ${Target.Type.Equal[NPC]}
				Face ${Target.X} ${Target.Z}
			elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
				Face ${Target.Target.X} ${Target.Target.Z}
		}
		elseif ${Me.Archetype.Equal[priest]}
		{
			echo im a priest
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-6.330657,-224.624207,9.0626244]}>2 && !${IconsDead}
				call Move -6.330657 -224.624207 9.0626244 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-9.74,-224.55,13.28]}>2 && ${IconsDead}
				call Move -9.74 -224.55 13.28 ${Precision} 0 FALSE FALSE TRUE FALE TRUE
			OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_combat TRUE
			OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_ca TRUE
			OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_namedca TRUE
			OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_rangedattack FALSE
			OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_meleeattack FALSE
			if ${Me.AutoAttackOn}
			{
				eq2ex toggleautoattack
			}
			if ${Trigger}
			{
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_combat FALSE
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_ca FALSE
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_disablecaststack_namedca FALSE
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_rangedattack TRUE
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_meleeattack TRUE
				Trigger:Set[FALSE]
				IconsDead:Set[TRUE]
			}
			if ${Target.Type.Equal[NPC]}
				Face ${Target.X} ${Target.Z}
			elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
				Face ${Target.Target.X} ${Target.Target.Z}
		}
		elseif (${Me.Archetype.Equal[scout]} || ${Me.Archetype.Equal[mage]})
		{
			Me.Maintained[Peaceful Link V]:Cancel
			Me.Maintained[Peaceful Link V]:Cancel
			Me.Maintained[Peaceful Link V]:Cancel
			Me.Maintained[Hyran's Seething Sonata III]:Cancel
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},0,-223.279663,0]}>2 && !${IconsDead}
				call Move 0 -223.279663 0 ${Precision} 0 FALSE FALSE TRUE FALE TRUE
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-9.74,-224.55,13.28]}>2 && ${IconsDead}
				call Move -9.74 -224.55 13.28 ${Precision} 0 FALSE FALSE TRUE FALE TRUE
			;activate fight
			if ${Me.Class.NotEqual[bard]} && ${Me.Class.NotEqual[enchanter]} && !${CustomActor[Warden,radius,75].IsAggro}
				call ClickChamberWarden
			;target whichever icon is aggro, or target self until they are all dead.
			if ${Actor[Matter].IsAggro}
			{
				OgreBotAtom aExecuteAtom ${Me} TargetThis Matter
				target Matter
			}
			elseif ${Actor[Pestilence].IsAggro}
			{
				OgreBotAtom aExecuteAtom ${Me} TargetThis Pestilence
				target Pestilence
			}
			elseif ${Actor[Force].IsAggro}
			{
				OgreBotAtom aExecuteAtom ${Me} TargetThis Force
				target Force
			}
			elseif ${Actor[Spirit].IsAggro}
			{
				OgreBotAtom aExecuteAtom ${Me} TargetThis Spirit
				target Spirit
			}
			elseif !${IconsDead}
			{
				OgreBotAtom aExecuteAtom ${Me} TargetThis ${Me}
				target ${Me}
			}
			if ${Trigger}
			{
				OgreBotAtom aExecuteAtom ${Me} TargetThis Warden
				target Warden
				Trigger:Set[FALSE]
				IconsDead:Set[TRUE]
			}
			if ${Target.Type.Equal[NPC]}
				Face ${Target.X} ${Target.Z}
			elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
				Face ${Target.Target.X} ${Target.Target.Z}
		}
	wait 2
	}
	;echo fight is over
	;restart ogre
	relay ${RI_Var_String_RelayGroup} -noredirect ogre reloadbot
	wait 50
	wait 20
	if ${Actor["ancestral column"](exists)}
	{
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_LetsGo all
		wait 10
		call LootChest
		wait 20
		Follow:Set[TRUE]
		call follow
		wait 10
		call Move ${Actor["ancestral column"].X} ${Actor["ancestral column"].Y} ${Actor["ancestral column"].Z} 5 0 FALSE FALSE TRUE FALSE TRUE
		wait 20
		Actor["ancestral column"]:DoubleClick
		wait 50
		while ${Me.InCombat} || ${Me.IsHated}
			wait 5
		while ${Actor[ragefire](exists)}
			wait 5
	}
	if !${GlobalOthers} && ${GlobalExitInstance}
	{
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_LetsGo all
		wait 10
		call LootChest
		wait 20
		Follow:Set[TRUE]
		call follow
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_QueueCommand EvacSpell
		wait 200
		call follow
		wait 10
		call Move -120.2 120.37 -36.23 2 0 FALSE FALSE TRUE FALSE TRUE
		wait 50
		call ClickStratumPillars
		wait 10
		relay ${RI_Var_String_RelayGroup} -noredirect endscript runinstances
	}
}
;script to automate Shazzak in Stratum
function Shazzak()
{
	;set Shazzak's ID
	variable int ShazzakID=${Actor[Shazzak].ID}
	;set LockSpot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot ALL -14.200039 1476.479248 9.489378 ${Precision} 100
	;if Shazzak exists and is not dead and Start, then move to positions and target named and adds
	while ${Actor[${ShazzakID}](exists)} && ${Start}
	{
		if ${Actor[Fragment](exists)} && !${GlobalOthers}
			target Fragment
		elseif !${GlobalOthers}
			target Shazzak
		if ${Target.Type.Equal[NPC]}
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
			Face ${Target.Target.X} ${Target.Target.Z}
		if ${Actor[${ShazzakID}].Distance}>20 && !${GlobalOthers}
			RI_Atom_ChangeLockSpot -14.200039 1476.479248 9.489378
		if ${Actor[${ShazzakID}].Distance}<20 && !${GlobalOthers}
			RI_Atom_ChangeLockSpot -29.753069 1475.186646 6.072108
		wait 1
	}
	;cancel lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot OFF
	wait 20
	if ${Actor["ancestral column"](exists)}
	{
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_LetsGo all
		wait 10
		call LootChest
		wait 20
		Follow:Set[TRUE]
		call follow
		wait 10
		call Move ${Actor["ancestral column"].X} ${Actor["ancestral column"].Y} ${Actor["ancestral column"].Z} 5 0 FALSE FALSE TRUE FALSE TRUE
		wait 20
		Actor["ancestral column"]:DoubleClick
		wait 50
		while ${Me.InCombat} || ${Me.IsHated}
			wait 5
		while ${Actor[ragefire](exists)}
			wait 5
	}
	if !${GlobalOthers} && ${GlobalExitInstance}
	{
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_LetsGo all
		wait 10
		call LootChest
		wait 20
		Follow:Set[TRUE]
		call follow
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_QueueCommand EvacSpell
		wait 200
		call follow
		wait 10
		call Move -177.11 1687.08 -0.39 2 0 FALSE FALSE TRUE FALSE TRUE
		wait 50
		call ClickStratumPillars
		wait 10
		relay ${RI_Var_String_RelayGroup} -noredirect endscript runinstances
	}
}
;script to ensure the group is not under water
function StratumCustomFallAndSwim()
{
	;make sure we keep falling in the right direction
	while ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-61.403519,1662.043579,-0.447757]}>${Precision} && ${Start}
	{
		if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-61.403519,1662.043579,-0.447757]}>${Precision}
			call Move -61.403519 1662.043579 -0.447757 ${Precision} 0 FALSE FALSE TRUE TRUE
		call ExecuteQueued
		while ${Me.Y}<1661
		{
			relay ${RI_Var_String_RelayGroup} -noredirect press -hold space
			wait 1
		}
		wait 1
	}
	relay ${RI_Var_String_RelayGroup} -noredirect press -release space
}
function Luminox()
{
	;set RedText var
	RedText:Set["The Core Guardian plants its feet"]
	;set initial lockspot position
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot ALL 50.977093 2.5308178 -20.537577 ${Precision} 125
	;while Luminox is within 50, and alive, target them, face them and wait for them to redtext then move
	while ${CustomActor[Luminox,radius,150](exists)} && !${CustomActor[Luminox,radius,150].IsDead} && ${Start}
	{
		if !${GlobalOthers}
			target Luminox
		if ${Target.Type.Equal[NPC]}
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
			Face ${Target.Target.X} ${Target.Target.Z}
		call ExecuteQueued
		if ${Trigger}
		{
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},50.977093,2.530817,-20.537577]}<5
				relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_ChangeLockSpot -50.686790 4.104009 -18.350060
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-50.686790,4.104009,-18.350060]}<5
				relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_ChangeLockSpot 50.977093 2.530817 -20.537577
			;wait 50
			Trigger:Set[FALSE]
		}
		wait 1
	}
	;cancel lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot OFF
}

;;;;; BELOW IS NOT BEING USED NO MORE 
function Maligned() 
{
	;set RedText var
	RedText:Set["The gyro hums and clanks"]
	;set initial lock positions
	variable float CNTempX=-435.495392
	variable float CNTempY=2.671357
	variable float CNTempZ=-83.085945
	;while Maligned is within 50, and alive, target them, face them and wait for them to redtext then move
	while ${CustomActor[Maligned,radius,150](exists)} && !${CustomActor[Maligned,radius,150].IsDead} && ${Start}
	{
		if !${GlobalOthers}
			target Maligned
		if ${Target.Type.Equal[NPC]}
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
			Face ${Target.Target.X} ${Target.Target.Z}
		if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
			call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call ExecuteQueued
		if ${Trigger}
		{
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-435.495392,2.671357,-83.085945]}<5
			{
				CNTempX:Set[-435.350403]
				CNTempY:Set[2.671630]
				CNTempZ:Set[83.829643]
			}
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-435.350403,2.671630,83.829643]}<5
			{
				CNTempX:Set[-435.495392]
				CNTempY:Set[2.671357]
				CNTempZ:Set[-83.085945]
			}
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
				call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 50
			Trigger:Set[FALSE]
		}
		wait 1
	}
}
;;;;; ABOVE IS NOT BEING USED NO MORE

function Prime()
{
	;set RedText var
	RedText:Set["Luminox Prime"]
	;set initial lock position
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot ALL 49.977093 2.530817 -19.537577 ${Precision} 125
	;while Prime is within 50, and alive, target them, face them and wait for them to redtext then move
	while ${CustomActor[Luminox,radius,150](exists)} && !${CustomActor[Luminox,radius,150].IsDead} && ${Start}
	{
		if !${GlobalOthers}
			target Luminox
		if ${Target.Type.Equal[NPC]}
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
			Face ${Target.Target.X} ${Target.Target.Z}
		call ExecuteQueued
		if ${Trigger} && ${TriggerMessage.Find[rends]}
		{
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},46.177093,2.710817,-18.137577]}<5
				relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_ChangeLockSpot -50.686790 4.104009 -18.350060
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-50.686790,4.104009,-18.350060]}<5
				relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_ChangeLockSpot 46.177093 2.710817 -18.137577
			wait 50
			Trigger:Set[FALSE]
		}
		elseif ${Trigger} && ${TriggerMessage.Find[firmly]}
		{
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},46.177093,2.710817,-18.137577]}<5
				relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_ChangeLockSpot 43.296790 4.354009 -0.580060
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-50.686790,4.104009,-18.350060]}<5
				relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_ChangeLockSpot -43.727093 4.280817 0.367577
			wait 50
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},43.296790,4.354009,-0.580060]}<5
				relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_ChangeLockSpot 46.177093 2.710817 -18.137577
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-43.727093,4.280817,0.367577]}<5
				relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_ChangeLockSpot -50.686790 4.104009 -18.350060
			Trigger:Set[FALSE]
		}
		wait 1
	}
	;cancel lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot OFF
	wait 20
	if ${Actor["ancestral column"](exists)}
	{
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_LetsGo all
		wait 10
		call LootChest
		wait 20
		Follow:Set[TRUE]
		call follow
		wait 10
		call Move ${Actor["ancestral column"].X} ${Actor["ancestral column"].Y} ${Actor["ancestral column"].Z} 5 0 FALSE FALSE TRUE FALSE TRUE
		wait 20
		Actor["ancestral column"]:DoubleClick
		wait 50
		while ${Me.InCombat} || ${Me.IsHated}
			wait 5
		while ${Actor[ragefire](exists)}
			wait 5
	}
	if !${GlobalOthers} && ${GlobalExitInstance}
	{
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_LetsGo all
		wait 10
		call LootChest
		wait 10
		Follow:Set[TRUE]
		call follow
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_QueueCommand EvacSpell
		wait 200
		call follow
		wait 10
		call Move ${Actor[nexus_zone_to_dragon_realm].X} ${Actor[nexus_zone_to_dragon_realm].Y} ${Actor[nexus_zone_to_dragon_realm].Z} 5 0 FALSE FALSE TRUE FALSE TRUE
		wait 50
		relay ${RI_Var_String_RelayGroup} -noredirect Actor[nexus_zone_to_dragon_realm]:DoubleClick
		wait 10
		relay ${RI_Var_String_RelayGroup} -noredirect endscript runinstances
	}
}
function ClickStratumPillars(bool Wait)
{
	wait 50
	while (${Me.InCombat} || ${Me.IsHated})
		wait 20
	wait 5
	variable int firstnumber = 30000
	variable int lastnumber = 39999
	variable int numbertemp
	numbertemp:Set[${firstnumber}]
	do
	{
		;echo ${firstnumber}
		if ${Actor[id,${numbertemp}](exists)}
			relay ${RI_Var_String_RelayGroup} -noredirect Actor[id,${numbertemp}]:DoubleClick
		numbertemp:Inc
	}
	while ${numbertemp}<=${lastnumber}
	if ${Wait}
		wait 200
}
function ClickChamberWarden(bool Wait)
{
	variable int firstnumber = 30000
	variable int lastnumber = 39999
	variable int numbertemp
	numbertemp:Set[${firstnumber}]
	do
	{
		;echo ${firstnumber}
		if ${Actor[id,${numbertemp}](exists)}
			Actor[id,${numbertemp}]:DoubleClick
		numbertemp:Inc
	}
	while ${numbertemp}<=${lastnumber}
	if ${Wait}
		wait 200
}
;script to run to and click blue bar in Pickclaw
function BlueBar()
{
	if ${GlobalOthers}
		return
	if ${Math.Distance[${Actor[glowing_blue_bar].X},${Actor[glowing_blue_bar].Z},${Actor[safe door 1].X},${Actor[safe door 1].Z}]}<5
	{
		call Move -69.303169 -127.900146 -114.277473 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		wait 5
		while ${CustomActor[glowing_blue_bar,radius,10](exists)} && ${Start}
		{
			Actor[glowing_blue_bar]:DoubleClick
			call ExecuteQueued
			wait 2
		}
		call Move -68.256676 -127.874298 -114.819595 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
	}
	if ${Math.Distance[${Actor[glowing_blue_bar].X},${Actor[glowing_blue_bar].Z},${Actor[safe door 2].X},${Actor[safe door 2].Z}]}<5
	{
		call Move -68.929187 -127.874298 -123.394295 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call Move -58.906429 -127.737289 -123.284164 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call Move -59.348614 -127.900146 -130.999832 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		wait 5
		while ${CustomActor[glowing_blue_bar,radius,10](exists)} && ${Start}
		{
			Actor[glowing_blue_bar]:DoubleClick
			call ExecuteQueued
			wait 2
		}
		call Move -58.906429 -127.737289 -123.284164 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call Move -68.929187 -127.874298 -123.394295 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call Move -68.974945 -127.900146 -137.110718 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
	}
	if ${Math.Distance[${Actor[glowing_blue_bar].X},${Actor[glowing_blue_bar].Z},${Actor[safe door 3].X},${Actor[safe door 3].Z}]}<5
	{
		call Move -68.929187 -127.874298 -123.394295 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call Move -77.923653 -127.609375 -123.552864 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call Move -77.614090 -127.900146 -131.322586 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		wait 5
		while ${CustomActor[glowing_blue_bar,radius,10](exists)} && ${Start}
		{
			Actor[glowing_blue_bar]:DoubleClick
			call ExecuteQueued
			wait 2
		}
		call Move -77.923653 -127.609375 -123.552864 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call Move -68.929187 -127.874298 -123.394295 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call Move -68.974945 -127.900146 -137.110718 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
	}
	if ${Math.Distance[${Actor[glowing_blue_bar].X},${Actor[glowing_blue_bar].Z},${Actor[safe door 4].X},${Actor[safe door 4].Z}]}<5
	{
		call Move -78.206055 -127.900146 -114.583939 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		wait 5
		while ${CustomActor[glowing_blue_bar,radius,10](exists)} && ${Start}
		{
			Actor[glowing_blue_bar]:DoubleClick
			call ExecuteQueued
			wait 2
		}
		call Move -68.256676 -127.874298 -114.819595 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
	}
}
function pie()
{
	if ${GlobalOthers}
		return
	;find closest pie
	variable int ClosestPie=${Actor[pie].ID}
	variable float ClosestPieX=${Actor[${ClosestPie}].X}
	variable float ClosestPieZ=${Actor[${ClosestPie}].Z}
	call Move ${ClosestPieX} -132.216980 ${ClosestPieZ} 4 0 FALSE FALSE TRUE FALSE TRUE
	wait 5
	while ${Actor[${ClosestPie}](exists)} && ${Start}
	{
		Actor[${ClosestPie}]:DoubleClick
		call ExecuteQueued
		wait 2
	}
}
function Bloogly()
{
	;set MobsID
	variable int BlooglyID=${CustomActor[Bloogly,radius,50].ID}
	variable int GuitaristID=${CustomActor[guitarist,radius,50].ID}
	variable int DrummerID=${CustomActor[drummer,radius,50].ID}
	;set initial lockspot
	RI_Atom_SetLockSpot ${Me.Name} -129.485794 -127.772461 -148.139740 ${Precision} 100
	;set groupmovebehind
	relay "other ${RI_Var_String_RelayGroup}" -noredirect RI_Atom_MoveBehind 1 ${BlooglyID} 30 99
	while ${Actor[id,${BlooglyID}](exists)}
	{
		if ${Actor[id,${GuitaristID}](exists)} && !${GlobalOthers}
		{
			if ${Target.ID}!=${GuitaristID}
				Actor[id,${GuitaristID}]:DoTarget
			if ${RI_Var_Int_MoveBehindMobID}!=${GuitaristID}
				RI_Var_Int_MoveBehindMobID:Set[${GuitaristID}]
		}
		elseif ${Actor[id,${DrummerID}](exists)} && !${GlobalOthers}
		{
			if ${Target.ID}!=${DrummerID}
				Actor[id,${DrummerID}]:DoTarget
			if ${RI_Var_Int_MoveBehindMobID}!=${DrummerID}
				RI_Var_Int_MoveBehindMobID:Set[${DrummerID}]
		}
		elseif ${Actor[id,${BlooglyID}](exists)} && !${GlobalOthers}
		{
			if ${Target.ID}!=${BlooglyID}
				Actor[id,${BlooglyID}]:DoTarget
			if ${RI_Var_Int_MoveBehindMobID}!=${BlooglyID}
				RI_Var_Int_MoveBehindMobID:Set[${BlooglyID}]
		}
		if ${Me.ToActor.IsFD}
			press x
		wait 2
	}
	;cancel lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot OFF
	;cancel movebehind
	relay "other ${RI_Var_String_RelayGroup}" -noredirect RI_Atom_MoveBehind 0
}
function Nurgal()
{
	;set RedText var
	;RedText:Set["A zombie begins to tremble"]
	;set initial lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot ALL -68.911987 -127.900009 -137.105164 ${Precision} 100
	;while Nurgal is within 50, and alive, target them, face them and wait for them to redtext then dont move
	while ${CustomActor[Nurgal,radius,50](exists)} && !${CustomActor[Nurgal,radius,50].IsDead} && ${Start}
	{
		if !${GlobalOthers}
			target Nurgal
		if ${Target.Type.Equal[NPC]}
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
			Face ${Target.Target.X} ${Target.Target.Z}
		call ExecuteQueued
		; if ${Trigger}
		; {
			; if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-68.911987,-127.900009,-137.105164]}<5
			; {
				; CNTempX:Set[-68.256676]
				; CNTempY:Set[-127.874298]
				; CNTempZ:Set[-114.819595]
			; }
			; elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-68.256676,-127.874298,-114.819595]}<5
			; {
				; CNTempX:Set[-68.911987]
				; CNTempY:Set[-127.900009]
				; CNTempZ:Set[-137.105164]
			; }
			; if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
				; call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			; wait 50
			; Trigger:Set[FALSE]
		; }
		wait 1
	}
	;cancel lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot OFF
}
function Serilis()
{
	variable int SerilisID=${CustomActor[Serilis,radius,150].ID}
	;set initial lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot ALL -4.025911 -166.268799 -171.448898 ${Precision} 100
	while ${Actor[id,${SerilisID}](exists)} && !${Actor[id,${SerilisID}].IsDead}
	{
		if ${CustomActor[pickclaw,radius,15](exists)} && !${GlobalOthers}
			target pickclaw
		;elseif !${GlobalOthers}
		;	target Serilis
		waitframe
	}
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot OFF
	wait 20
	if ${Actor["ancestral column"](exists)}
	{
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_LetsGo all
		wait 10
		call LootChest
		wait 20
		Follow:Set[TRUE]
		call follow
		wait 10
		call Move -35.01 -165.56 -154.90 2 0 FALSE FALSE TRUE FALSE TRUE
		call Move ${Actor["ancestral column"].X} ${Actor["ancestral column"].Y} ${Actor["ancestral column"].Z} 5 0 FALSE FALSE TRUE FALSE TRUE
		wait 20
		Actor["ancestral column"]:DoubleClick
		wait 50
		while ${Me.InCombat} || ${Me.IsHated}
			wait 5
		while ${Actor[ragefire](exists)}
			wait 5
	}
	if !${GlobalOthers} && ${GlobalExitInstance}
	{
		wait 10
		call LootChest
		wait 20
		if ${ISXOgre(exists)}
			relay "other ${RI_Var_String_RelayGroup}" -noredirect OgreBotAtom a_LetsGo all
		Follow:Set[TRUE]
		call follow
		wait 10
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_QueueCommand EvacSpell
		wait 200
		call follow
		wait 10
		call Move ${Actor[exit].X} ${Actor[exit].Y} ${Actor[exit].Z} 2 0 FALSE FALSE TRUE FALSE TRUE
		wait 50
		relay ${RI_Var_String_RelayGroup} -noredirect Actor[exit]:DoubleClick
		wait 10
		relay ${RI_Var_String_RelayGroup} -noredirect endscript runinstances
	}
}

;BELOW NEEDS TO BE UPDATED TO RIMOVEMENT
function Hammy()
{
	;target and pull
	if !${GlobalOthers}
		target Hammy
	;wait until hammy is to us
	while ${Actor[Hammy].Distance}>10 && ${Start}
	{ 
	;need to add an isaggro check 
		if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-126.527992,-110.023376,74.592873]}>2
			call Move -126.527992 -110.023376 74.592873 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		wait 2
		if !${GlobalOthers}
			target Hammy
		call ExecuteQueued
	}
	while ${Actor[Hammy](exists)} && ${Start}
	;need to add someway for it not to end the fight when hammy changes
	{
		;starting movement for hammy
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 1
			call Move -110 -110.023376 79 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
		;check for hog trap
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 2
			call Move -110 -110.023376 58 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
		;check for hog trap
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 3
			call Move -110 -110.023376 42 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
		;check for hog trap
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 4
			call Move -93 -110.023376 40 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
		;check for hog trap
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 5
			call Move -93 -110.023376 53 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
		;check for hog trap
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 6
			call Move -82 -110 42 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
		;check for hog trap
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 7
			call Move -57 -110.023376 47 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
		;check for hog trap
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 8
			call Move -63 -110.023376 85 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
		;check for hog trap
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 9
			call Move -85 -110.023376 61 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
		;check for hog trap
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 10
			call Move -83 -110.023376 93 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
		;check for hog trap
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 11
			call Move -124 -110.023376 20 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
		;check for hog trap
		if !${Actor[hog_trap](exists)}
		{
			;move to crate 12
			call Move -131 -110.023376 49 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			wait 10
			while ${Actor[a storage crate].Distance}<5 && ${Start}
			{
				wait 5
				call ExecuteQueued
			}
			wait 20
		}
	}
}
function Bazziz()
{
	;set incomingtext
	IncomingText:Set["Run them down, my pets!"]
	;set initial lock positions
	variable float CNTempX=-8.837314
	variable float CNTempY=-32.191406
	variable float CNTempZ=-369.822449
	if !${GlobalOthers}
		target Bazziz
	;while the bazziz exists and is not dead target them, face them and lock our spot
	while ${CustomActor[Bazziz,radius,75](exists)} && !${Actor[Bazziz}].IsDead} && ${Start}
	{
		if ${Target.Type.Equal[NPC]}
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
			Face ${Target.Target.X} ${Target.Target.Z}
		if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
			call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call ExecuteQueued
		if ${Trigger}
		{
			wait 500 (!${Actor[Grizzly].IsAggro})
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-8.837314,-32.191406,-369.822449]}<5
			{
				CNTempX:Set[-5.363069]
				CNTempY:Set[-30.095713]
				CNTempZ:Set[-378.337738]
			}
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-5.363069,-30.095713,-378.337738]}<5
			{
				CNTempX:Set[-29.030668]
				CNTempY:Set[-32.908146]
				CNTempZ:Set[-372.483582]
			}
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-29.030668,-32.908146,-372.483582]}<5
			{
				CNTempX:Set[-5.363069]
				CNTempY:Set[-30.095713]
				CNTempZ:Set[-378.337738]
			}
			wait 2
			Trigger:Set[FALSE]
		}
		wait 1
	}
}
function Monstrous()
{
	;set RedText var
	RedText:Set["The Roc gazes at you"]
	;set initial lock positions
	variable float CNTempX=173.203323
	variable float CNTempY=-62.823399
	variable float CNTempZ=-224.803543
	variable int MonstrousID=${CustomActor[Monstrous,radius,50].ID}
	;while Monstrous is within 50, and alive, target them, face them and wait for them to redtext then move
	while ${Actor[id,${MonstrousID}](exists)} && !${Actor[id,${MonstrousID}].IsDead} && ${Start}
	{
		if !${GlobalOthers}
			target Monstrous
		if ${Target.Type.Equal[NPC]}
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
			Face ${Target.Target.X} ${Target.Target.Z}
		if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
			call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call ExecuteQueued
		; if ${Trigger}
		; { SHUT OFF BECAUSE THE EGG IS WEAK AS FUCK
			;;set joust location
			; CNTempX:Set[173.309128]  
			; CNTempY:Set[-61.080784]
			; CNTempZ:Set[-211.576660]
			; variable int count
			;;lock in place for 15s
			; for (count:Set[1] ; ${count}<=150 ; count:Inc)
			; {
				; if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
					; call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
				; wait 1
			; }
			;;set original location
			; CNTempX:Set[173.203323]  
			; CNTempY:Set[-62.823399]
			; CNTempZ:Set[-224.803543]
			; Trigger:Set[FALSE]
		; }
		wait 1
	}
	if ${GlobalOthers}
		return
	wait 10
	call LootChest
	wait 10
	Follow:Set[TRUE]
	call follow
	wait 10
}
function ether-charged()
{	
	variable float CNTempX=173.203323
	variable float CNTempY=-62.823399
	variable float CNTempZ=-224.803543

	while ${CustomActor[ether-charged,radius,25](exists)} && ${Start}
	{
		;add timedcommand to set variable to move to flammicum joust spot then another timed command 7s to move back
		TimedCommand 60 Script[Buffer:RunInstances].Variable[Trigger]:Set[TRUE]
		if ${Trigger}
		{
			;set joust location
			CNTempX:Set[173.309128]
			CNTempY:Set[-61.080784]
			CNTempZ:Set[-211.576660]
			;set timer
			Trigger:Set[FALSE]
			TimedCommand 60 Script[Buffer:RunInstances].Variable[Trigger]:Set[TRUE]
			wait 20
			;set original location
			CNTempX:Set[173.309128]  
			CNTempY:Set[-61.080784]
			CNTempZ:Set[-211.576660]
		}
		if !${GlobalOthers}
			target ether-charged
		if (${Target.Type.Equal[NPC]} || ${Target.Type.Equal[NamedNPC]})
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && (${Target.Target.Type.Equal[NPC]} || ${Target.Target.Type.Equal[NamedNPC]})
			Face ${Target.Target.X} ${Target.Target.Z}
		if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
			call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		wait 2
	}
	TimedCommand 70 Script[Buffer:RunInstances].Variable[Trigger]:Set[FALSE]
}
function Flammicuum()
{
	variable float CNTempX=173.203323
	variable float CNTempY=-62.823399
	variable float CNTempZ=-224.803543
	variable int FlammicuumID=${CustomActor[Flammicuum,radius,50].ID}
	while ${GlobalOthers} && ${Actor[id,${FlammicuumID}](exists)} && !${Actor[id,${FlammicuumID}].IsDead} && ${Start}
		wait 10
	if ${GlobalOthers}
		return
	;turn on follow
	Follow:Set[TRUE]
	call follow
	;while Flammicum is within 50, and alive, target them, face them and wait for them to cast implosion then move
	while ${Actor[id,${FlammicuumID}](exists)} && !${Actor[id,${FlammicuumID}].IsDead} && ${Start}
	{
		if !${GlobalOthers}
			target Flammicuum
		if ${Target.Type.Equal[NPC]}
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
			Face ${Target.Target.X} ${Target.Target.Z}
		if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
			call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call ExecuteQueued
		if ${Me.GetGameData[Target.Casting].Label.Find[Implosion]}
		{
			;set joust location
			CNTempX:Set[173.309128]  
			CNTempY:Set[-61.080784]
			CNTempZ:Set[-211.576660]
			;lock in place until he is done casting implosion
			while ${Me.GetGameData[Target.Casting].Label.Find[Implosion]}
			{
				if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
					call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
				wait 1
			}
			wait 5
			;set original location
			CNTempX:Set[173.203323]  
			CNTempY:Set[-62.823399]
			CNTempZ:Set[-224.803543]
		}
		wait 1
	}
	wait 10
}
function General()
{
	;set initial lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot ALL -31.726255 -110.004517 -32.205574 ${Precision} 100
	while ${Actor[General](exists)} && !${Actor[General].IsDead} && ${Start}
	{
		if !${GlobalOthers}
			target General
		if (${Target.Type.Equal[NPC]} || ${Target.Type.Equal[NamedNPC]})
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && (${Target.Target.Type.Equal[NPC]} || ${Target.Target.Type.Equal[NamedNPC]})
			Face ${Target.Target.X} ${Target.Target.Z}
		call ExecuteQueued
		wait 1
	}
	;cancel lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot OFF
	wait 20
	if ${Actor["ancestral column"](exists)}
	{
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_LetsGo all
		wait 10
		call LootChest
		wait 20
		Follow:Set[TRUE]
		call follow
		wait 10
		call Move ${Actor["ancestral column"].X} ${Actor["ancestral column"].Y} ${Actor["ancestral column"].Z} 5 0 FALSE FALSE TRUE FALSE TRUE
		wait 20
		Actor["ancestral column"]:DoubleClick
		wait 50
		while ${Me.InCombat} || ${Me.IsHated}
			wait 5
		while ${Actor[ragefire](exists)}
			wait 5
	}
	if !${GlobalOthers} && ${GlobalExitInstance}
	{
		wait 10
		call Move ${Actor[chest].X} ${Actor[chest].Y} ${Actor[chest].Z} 2 0 FALSE FALSE TRUE FALSE TRUE
		wait 10
		call LootChest
		wait 20
		if ${ISXOgre(exists)}
			relay "other ${RI_Var_String_RelayGroup}" -noredirect OgreBotAtom a_LetsGo all
		Follow:Set[TRUE]
		call follow
		wait 10
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_QueueCommand EvacSpell
		wait 200
		call follow
		wait 10
		call Move -135.33 -36.42 89.03 2 0 FALSE FALSE TRUE FALSE TRUE
		wait 50
		relay ${RI_Var_String_RelayGroup} -noredirect Actor[zone]:DoubleClick
		wait 10
		relay ${RI_Var_String_RelayGroup} -noredirect endscript runinstances
	}
}
function Meacidaris()
{	
	;set initial lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot ALL 123.477257 -23.582417 -419.882843 ${Precision} 100
	while ${Actor[Meacidaris](exists)} && !${Actor[Meacidaris].IsDead} && ${Start}
	{
		if ${CustomActor[wax,radius,50](exists)} && !${CustomActor[wax,radius,50].IsDead} && !${GlobalOthers}
			target wax
		elseif ${CustomActor[guard,radius,25](exists)} && !${CustomActor[guard,radius,50].IsDead} && !${GlobalOthers}
			target guard
		elseif ${CustomActor[worker,radius,10](exists)} && !${CustomActor[worker,radius,50].IsDead} && !${GlobalOthers}
			target worker
		elseif !${GlobalOthers}
			target Meacidaris
		if (${Target.Type.Equal[NPC]} || ${Target.Type.Equal[NamedNPC]})
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && (${Target.Target.Type.Equal[NPC]} || ${Target.Target.Type.Equal[NamedNPC]})
			Face ${Target.Target.X} ${Target.Target.Z}
		call ExecuteQueued
		wait 1
	}
	;cancel lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot OFF
	wait 20
	if ${Actor["ancestral column"](exists)}
	{
		echo Ancestral Column Exists Moving to it
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_LetsGo all
		wait 10
		call LootChest
		wait 20
		Follow:Set[TRUE]
		call follow
		wait 10
		call Move 125.19 -23.59 -405.92 2 0 FALSE FALSE TRUE FALSE TRUE
		call Move 125.19 -23.59 -385.92 2 0 FALSE FALSE TRUE FALSE TRUE
		call Move ${Actor["ancestral column"].X} ${Actor["ancestral column"].Y} ${Actor["ancestral column"].Z} 5 0 FALSE FALSE TRUE FALSE TRUE
		wait 20
		Actor["ancestral column"]:DoubleClick
		wait 50
		while ${Me.InCombat} || ${Me.IsHated}
			wait 5
		while ${Actor[ragefire](exists)}
			wait 5
	}
	if !${GlobalOthers} && ${GlobalExitInstance}
	{
		wait 10
		call LootChest
		wait 20
		if ${ISXOgre(exists)}
			relay "other ${RI_Var_String_RelayGroup}" -noredirect OgreBotAtom a_LetsGo all
		Follow:Set[TRUE]
		call follow
		wait 10
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_QueueCommand EvacSpell
		wait 200
		if ${ISXOgre(exists)}
			relay "other ${RI_Var_String_RelayGroup}" -noredirect OgreBotAtom a_LetsGo all
		call follow
		wait 10
		if ${ISXOgre(exists)}
			relay "other ${RI_Var_String_RelayGroup}" -noredirect OgreBotAtom a_LetsGo all
		call follow
		wait 10
		call Move -147.54 -45.76 -205.74 2 0 FALSE FALSE TRUE FALSE TRUE
		wait 50
		relay ${RI_Var_String_RelayGroup} -noredirect Actor[zone]:DoubleClick
		wait 10
		relay ${RI_Var_String_RelayGroup} -noredirect endscript runinstances
	}
}
function Yothsra()
{
	variable int YothsraID=${Actor[Yothsra].ID}
	;set initial lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot ALL 6.982520 64.432648 -3.524385 ${Precision} 100
	;set incomingtext
	IncomingText:Set["Yothsra summons a storm!"]
	;if Yothsra exists and is not dead and Start, then move to positions based on text and target correct mobs
	while (${CustomActor[Yothsra,radius,50](exists)} || ${CustomActor[hunter,radius,50](exists)} || ${CustomActor[crawler,radius,50](exists)})	&& ${Start}
	{
		if ${CustomActor[hunter,radius,50](exists)} && !${GlobalOthers}
		{
			relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_donotsave_dynamicignorepbae TRUE
			relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_donotsave_dynamicignoreencounternukes TRUE
			Actor[id,${CustomActor[hunter,notid,${YothsraID}].ID}]:DoTarget
		}
		elseif ${CustomActor[crawler,radius,50](exists)} && !${GlobalOthers}
			Actor[id,${CustomActor[crawler,notid,${YothsraID}].ID}]:DoTarget
		else
		{
			relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_donotsave_dynamicignorepbae FALSE
			relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_donotsave_dynamicignoreencounternukes FALSE
			if !${GlobalOthers}
				target Yothsra
		}
		if ${Target.Type.Equal[NPC]}
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
			Face ${Target.Target.X} ${Target.Target.Z}
		if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},6.982520,64.432648,-3.524385]}<5 && ${Trigger}
			relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_ChangeLockSpot -17.939279 64.400784 20.397612
		elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-17.939279,64.400784,20.397612]}<5 && ${Trigger}
			relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_ChangeLockSpot 6.982520 64.432648 -3.524385
		if ${Trigger}
			Trigger:Set[FALSE]
		call ExecuteQueued
		wait 2
	}
	;cancel lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot OFF
}
;need to change below function to use RIMovement and decide if we wanna use changecampspotby
function Nemesis()
{
	;set RedText var
	RedText:Set["Nemesis Arcanox begins to create a black hole"]
	;set initial lock positions
	variable float CNTempX=72.118027
	variable float CNTempY=64.649902
	variable float CNTempZ=30.758787
	;get Nemesis Arcanox ID
	variable int ArcanoxID=${CustomActor[Arcanox,radius,20].ID}
	;while Nemesis is within 50, and alive, target them, face them and wait for them to redtext then move
	while ${Actor[id,${ArcanoxID}](exists)} && ${Start}
	{
		if !${GlobalOthers} && ${CustomActor[Elementox,radius,50](exists)} && !${CustomActor[Elementox,radius,50].IsDead}
			target Elementox
		elseif !${GlobalOthers}
			target Arcanox
		if ${Target.Type.Equal[NPC]}
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
			Face ${Target.Target.X} ${Target.Target.Z}
		if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
			call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		call ExecuteQueued
		if ${Trigger}
		{
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},72.118027,64.649902,30.758787]}<5
			{
				CNTempX:Set[77.84]
				CNTempY:Set[64.40]
				CNTempZ:Set[6.40]
			}
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},77.84,64.40,6.40]}<5
			{
				CNTempX:Set[77.41]
				CNTempY:Set[64.45]
				CNTempZ:Set[-15.44]
			}
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},77.41,64.45,-15.44]}<5
			{
				CNTempX:Set[71.97]
				CNTempY:Set[64.50]
				CNTempZ:Set[-31.05]
			}
			elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},71.97,64.50,-31.05]}<5
			{
				CNTempX:Set[61.02]
				CNTempY:Set[64.51]
				CNTempZ:Set[-48.62]
			}
			wait 2
			Trigger:Set[FALSE]
		}
		wait 1
	}
	wait 10
	call LootChest
	wait 10
	Follow:Set[TRUE]
	call follow
	wait 10
}
function Ziskaya()
{
	echo running ziskaya function
	;set RedText var
	RedText:Set["Reflect"]
	variable int ZiskayaID=${CustomActor[Ziskaya,radius,25].ID}
	;set initial lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot ALL -131.886810 -24.24 29.268892 ${Precision} 100
	;while Ziskaya is within 50, and alive, target them, face them and wait for them to redtext then target self for 10s
	while ${Actor[id,${ZiskayaID}](exists)} && !${Actor[id,${ZiskayaID}].IsDead} && ${Start}
	{
		;if we see the trigger and are not others target me for 10s
		if ${Trigger} && !${GlobalOthers}
		{
			target ${Me.Name}
			wait 100
			Trigger:Set[FALSE]
		}
		elseif !${GlobalOthers}
			Actor[id,${ZiskayaID}]:DoTarget
		if ${Target.Type.Equal[NPC]}
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && ${Target.Target.Type.Equal[NPC]}
			Face ${Target.Target.X} ${Target.Target.Z}
		call ExecuteQueued
		wait 1
	}
	;cancel lockspot
	relay ${RI_Var_String_RelayGroup} -noredirect RI_Atom_SetLockSpot OFF
}
;need to change below function to use RIMovement
function Aegragis()
{
	;set incomingtext
	IncomingText:Set["begins casting a powerful spell!"]
	;set initial lock positions and barrel variables
	variable float CNTempX=-0.81
	variable float CNTempY=108.94
	variable float CNTempZ=1138.38
	variable float TCNTempX=9.94
	variable float TCNTempY=109.92
	variable float TCNTempZ=1140.54
	variable bool WestSideBarrelsBlown=FALSE
	variable bool EastSideBarrelsBlown=FALSE
	variable bool 2ndStoneskinDone=FALSE
	variable int WestSideBarrelsID
	variable int EastSideBarrelsID
	;if we are a fighter then move to pull position, target and wait until he is at us
	if ${Me.Archetype.Equal[fighter]}
	{
		WestSideBarrelsID:Set[${CustomActor[Barrels].ID}]
		echo ${WestSideBarrelsID}
		EastSideBarrelsID:Set[${CustomActor[Barrels,notid,${WestSideBarrelsID}].ID}]
		echo ${EastSideBarrelsID}
		call Move 8.75 109.33 1106.75 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		echo call Move 8.75 109.33 1106.75 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		target Aegragis
		wait 2000 ${CustomActor[Aegragis,radius,10](exists)}
		echo he is at us
	}
	;execute while Aegragis exists and is not dead 
	while ${CustomActor[Aegragis,radius,100](exists)} && !${CustomActor[Aegragis,radius,100].IsDead}
	{
		;if we are a fighter move to various lock spots and barrel spots based on incomingtext and health
		if ${Me.Archetype.Equal[fighter]}
		{
			if ${Actor[Protector,radius,40](exists)}
				target Protector
			elseif ${Actor[gearbox,radius,40](exists)}
				target gearbox
			else
				target Aegragis
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${TCNTempX},${TCNTempY},${TCNTempZ}]}>2
			{
				echo call Move ${TCNTempX} ${TCNTempY} ${TCNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
				call Move ${TCNTempX} ${TCNTempY} ${TCNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			}
			if ${CustomActor[Aegragis,radius,100].Health}<76 && ${Actor[${WestSideBarrelsID}](exists)} && ${Actor[${EastSideBarrelsID}](exists)}
			{
				if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},14.23,108.94,1119.17]}<30
				{
					echo call Move 14.23 108.94 1119.17 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					call Move 14.23 108.94 1119.17 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					wait 2000 (${CustomActor[Aegragis,radius,10](exists)} || ${Trigger} || ${CustomActor[Aegragis,radius,100].IsDead})
					echo call Move 6.22 108.94 1128.93 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					call Move 6.22 108.94 1128.93 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					wait 2000 (${Trigger} || ${CustomActor[Aegragis,radius,100].IsDead})
				}
				elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-40.28,108.94,1124.41]}<30
				{
					echo call Move -40.28 108.94 1124.41 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					call Move -40.28 108.94 1124.41 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					wait 2000 (${CustomActor[Aegragis,radius,10](exists)} || ${Trigger} || ${CustomActor[Aegragis,radius,100].IsDead})
					echo call Move -30.21 108.94 1132.28 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					call Move -30.21 108.94 1132.28 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					wait 2000 (${Trigger} || ${CustomActor[Aegragis,radius,100].IsDead})
				}
			}
			if ${CustomActor[Aegragis,radius,100].Health}<26 && (${Actor[${WestSideBarrelsID}](exists)} || ${Actor[${EastSideBarrelsID}](exists)})
			{
				if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},14.23,108.94,1119.17]}<30 && ${Actor[${WestSideBarrelsID}](exists)}
				{
					echo call Move 14.23 108.94 1119.17 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					call Move 14.23 108.94 1119.17 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					wait 2000 (${CustomActor[Aegragis,radius,10](exists)} || ${Trigger} || ${CustomActor[Aegragis,radius,100].IsDead})
					echo call Move 6.22 108.94 1128.93 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					call Move 6.22 108.94 1128.93 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					wait 2000 (${Trigger} || ${CustomActor[Aegragis,radius,100].IsDead})
				}
				elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-40.28,108.94,1124.41]}<30 && ${Actor[${EastSideBarrelsID}](exists)}
				{
					echo call Move -40.28 108.94 1124.41 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					call Move -40.28 108.94 1124.41 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					wait 2000 (${CustomActor[Aegragis,radius,10](exists)} || ${Trigger} || ${CustomActor[Aegragis,radius,100].IsDead})
					echo call Move -30.21 108.94 1132.28 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					call Move -30.21 108.94 1132.28 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
					wait 2000 (${Trigger} || ${CustomActor[Aegragis,radius,100].IsDead})
				}
			}
			if ${Trigger}
			{
				if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},9.94,109.92,1140.54]}<30
				{
					TCNTempX:Set[-33.75]
					TCNTempY:Set[109.80]
					TCNTempZ:Set[1140.63]
				}
				elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-33.75,109.80,1140.63]}<30
				{
					TCNTempX:Set[9.94]
					TCNTempY:Set[109.92]
					TCNTempZ:Set[1140.54]
				}
				wait 2
				call Move ${TCNTempX} ${TCNTempY} ${TCNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
				wait 100 ${CustomActor[Aegragis,radius,100].IsDead}
				Trigger:Set[FALSE]
			}
		}
		;if everyone else move to corresponding lockspots based on incomingtext and distance from mob
		else
		{
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
			{
				echo call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
				call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			}
			call ExecuteQueued
			if ${Trigger}
			{
				if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-0.81,108.94,1138.38]}<5 && ${Actor[Aegragis].Distance}<20
				{
					CNTempX:Set[-24.21]
					CNTempY:Set[108.94]
					CNTempZ:Set[1140.59]
				}
				elseif ${Math.Distance[${Me.X},${Me.Y},${Me.Z},-24.21,108.94,1140.59]}<5  && ${Actor[Aegragis].Distance}<20
				{
					CNTempX:Set[-0.81]
					CNTempY:Set[108.94]
					CNTempZ:Set[1138.38]
				}
				wait 2
				Trigger:Set[FALSE]
			}
		}
	}
	echo Aegragis is Dead Moving on
	wait 10
	if !${GlobalOthers}
	{
		if ${ISXOgre(exists)}
			relay "other ${RI_Var_String_RelayGroup}" -noredirect OgreBotAtom a_LetsGo all
		Follow:Set[TRUE]
		call follow
		call LootChest
	}
}
function Dagrin()
{
	NameID:Set[${Actor[Dagrin].ID}]
	if !${GlobalOthers}
	{
		Actor[${NameID}]:DoTarget
		eq2ex togglerangedattack
	}
	if !${GlobalOthers}
	{
		call Move -390.666260 211.936234 2070.244385 2 0 FALSE FALSE TRUE FALSE TRUE
	}
	if ${GlobalOthers}
	{
		wait 50
		call Move -390.666260 211.936234 2070.244385 2 0 FALSE FALSE TRUE FALSE TRUE
	}
	wait 5000 ${Actor[id,${NameID}].Distance}<35
	while ${Actor[id,${NameID}](exists)}
	{
		if ${Me.Archetype.Equal[fighter]}
		{
			;face named
			Face ${Actor[id,${NameID}].X} ${Actor[id,${NameID}].Z}
			;if we are not targeting named target
			if ${Target.ID} != ${NameID}
				target dagrin
			;if we are more than 3 from the named and not pressing forward, do so
			if (${Target.Distance2D}>3 && !${Input.Button[${ForwardKey}].Pressed})
				press -hold ${ForwardKey}
			;once we are less than 3, stop pressing forward
			elseif ${Target.Distance2D}<=3
				press -release ${ForwardKey}
		}
		else
		{
			if ${Me.Class.Equal[bard]} && ${Actor[Malformation](exists)}
			{
				;turn off auto assist
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_assist FALSE
				RI_Atom_MoveBehind 0
				while ${Actor[Malformation](exists)}
				{
					;target malformation, if we arent
					if ${Target.Name.NotEqual["Magmatic Malformation"]}
						Target Malformation
					;face malformation
					Face ${Actor[Malformation].X} ${Actor[Malformation].Z}
					;if we are more than 3 from the malformation and not pressing forward, do so
					if (${Target.Distance2D}>5
						press -hold ${ForwardKey}
					;once we are less than 3, stop pressing forward
					elseif ${Target.Distance2D}<=5
						press -release ${ForwardKey}
					;cast sprint, if ready
					if ${Me.Ability[Sprint].IsReady}
						Me.Ability[Sprint]:Use
					waitframe
				}
				while ${Math.Distance[${Me.X},${Me.Z},${Actor[id,${NameID}].X},${Actor[id,${NameID}].Z}]}>29
				{
					;target Malformation, if we arent
					if ${Target.ID}!=${NameID}
						Actor[id,${NameID}]:DoTarget
					;face malformation
					Face ${Actor[id,${NameID}].X} ${Actor[id,${NameID}].Z}
					;if we are more than 3 from the malformation and not pressing forward, do so
					if (${Target.Distance2D}>5
						press -hold ${ForwardKey}
					;once we are less than 3, stop pressing forward
					elseif ${Target.Distance2D}<=5
						press -release ${ForwardKey}
					;cast sprint, if ready
					if ${Me.Ability[Sprint].IsReady}
						Me.Ability[Sprint]:Use
					waitframe
				}
				if ${Input.Button[${ForwardKey}].Pressed}
					press -release ${ForwardKey}
				;turn on auto assist
				OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_assist TRUE
				RI_Atom_MoveBehind 1 ${NameID} 30 99
			}
			;if our ${Position.Angle[${NameID}]} is less than 45, meaning not behind, call function
			if (${Target.Target.Distance2D}>${Position.GetMeleeMaxRange[${NameID}]} || ${Position.Angle[${NameID}]}>45)
			{
				RI_Atom_MoveBehind 1 ${NameID} 30 99
			}
			;we are behind, waiting 10
			wait 10
		}
		waitframe
	}
	if ${GlobalOthers}
		RI_Atom_MoveBehind 0
	wait 100
}
function Getiar()
{
	if !${GlobalOthers}
	{
		target Getiar
		eq2ex togglerangedattack
		;set my lockspot
		RI_Atom_SetLockSpot ${Me.Name} 1105.252319 203.971985 2846.019775 ${Precision} 100
		variable int Count
		for(Count:Set[1];${Count}<=10;Count:Inc)
		{
			if ${Target.ID}!=${NameID} && !${GlobalOthers}
				target Getiar
			wait 10
		}
		;set others lockspot
		relay "other ${RI_Var_String_RelayGroup}" -noredirect RI_Atom_SetLockSpot ALL 1105.252319 203.971985 2846.019775 ${Precision} 100
	}
	while ${Actor[id,${NameID}](exists)} && !${Actor[id,${NameID}].IsDead} && ${Start}
	{
		;if ${CustomActor[scorching,radius,50](exists)} && !${GlobalOthers}
		;	target scorching
		if !${GlobalOthers}
			target Getiar
		if (${Target.Type.Equal[NPC]} || ${Target.Type.Equal[NamedNPC]})
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && (${Target.Target.Type.Equal[NPC]} || ${Target.Target.Type.Equal[NamedNPC]})
			Face ${Target.Target.X} ${Target.Target.Z}
		wait 2
	}
	call ExecuteQueued
	wait 50
}
function Switch()
{
	while (${Me.Group[1].ToActor.Distance}>5 || ${Me.Group[2].ToActor.Distance}>5 || ${Me.Group[3].ToActor.Distance}>5 || ${Me.Group[4].ToActor.Distance}>5 || ${Me.Group[5].ToActor.Distance}>5)
		wait 1
	;call on others
	if !${GlobalOthers}
		relay "other ${RI_Var_String_RelayGroup}" -noredirect Script[Buffer:RunInstances]:QueueCommand["call Switch"]
	;set RedText var
	RedText:Set[You hear the grinding of metal gears moving something very large!]
	while !${Trigger}
	{
		if ${Me.Class.Equal[bard]} || ${Me.Archetype.Equal[priest]}
		{
			if ${ISXOgre(exists)}
				OgreBotAtom a_QueueCommand DoNotMove
			call Move 76.451630 137.825912 1059.932983 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move 139.440598 141.609894 983.305664 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move 171.069489 143.754440 947.623108 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move 180.144394 143.881821 870.679626 2 0 FALSE FALSE TRUE FALSE FALSE
			wait 10
			relay ${RI_Var_String_RelayGroup} -noredirect R2There:Set[TRUE]
			while !${R1There}
				wait 1
			while !${Trigger}
			{
				Actor[${Actor["Portcullis Switch"].ID}]:DoubleClick
				wait 1
			}
			call Move 171.069489 143.754440 947.623108 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move 139.440598 141.609894 983.305664 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move 76.451630 137.825912 1059.932983 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move 10.714638 147.006439 1134.286133 2 0 FALSE FALSE TRUE FALSE FALSE
			if ${ISXOgre(exists)}
				OgreBotAtom a_LetsGo ${Me.Name}
		}
		elseif ${Me.Archetype.Equal[mage]} || ${Me.Archetype.Equal[scout]}
		{
			if ${ISXOgre(exists)}
				OgreBotAtom a_QueueCommand DoNotMove
			call Move -58.973568 143.927155 1142.5450440 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move -127.579964 143.541428 1070.661255 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move -195.804916 146.215134 998.558716 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move -235.331619 142.038330 924.1931760 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move -221.331619 142.038330 901.1931760 2 0 FALSE FALSE TRUE FALSE FALSE
			wait 10
			relay ${RI_Var_String_RelayGroup} -noredirect R1There:Set[TRUE]
			while !${R2There}
				wait 1
			while !${Trigger}
			{
				Actor[${Actor["Portcullis Switch"].ID}]:DoubleClick
				wait 1
			}
			wait 30
			call Move -195.804916 146.215134 998.558716 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move -127.579964 143.541428 1070.661255 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move -58.973568 143.927155 1142.545044 2 0 FALSE FALSE TRUE TRUE FALSE
			call Move 10.714638 147.006439 1134.286133 2 0 FALSE FALSE TRUE FALSE FALSE
			if ${ISXOgre(exists)}
				OgreBotAtom a_LetsGo ${Me.Name}
		}
		else
		{
			while !${R1There} && !${R2There}
				wait 1
			Actor[${Actor["Portcullis Switch"].ID}]:DoubleClick
		}
		wait 1
	}
	Trigger:Set[FALSE]
	while (${Me.Group[1].ToActor.Distance}>10 || ${Me.Group[2].ToActor.Distance}>10 || ${Me.Group[3].ToActor.Distance}>10 || ${Me.Group[4].ToActor.Distance}>10 || ${Me.Group[5].ToActor.Distance}>10)
		wait 1
}
function Ahrmatal()
{
	if ${ISXOgre(exists)}
	{
		OgreBotAtom a_MoveToCampSpot all
		OgreBotAtom a_SetUpFor all Ahrmatal
		Ogre_CampSpot:Set_ChangeCampSpotBy[${Me.Name},0,0,-20]
		target Ahrmatal
		while ${CustomActor[Ahrmatal,radius,100](exists)} && !${CustomActor[Ahrmatal,radius,100].IsDead}
		{
			;if ${CustomActor[scorching,radius,15](exists)} && !${CustomActor[scorching,radius,15].IsDead} && !${GlobalOthers}
			;	target scorching
			if !${GlobalOthers} 
				target ahrmatal
			wait 2
		}
	}
	else
	{
		while ${CustomActor[Ahrmatal,radius,100](exists)}
			wait 2
	}
	wait 20
	if ${Actor["ancestral column"](exists)}
	{
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_LetsGo all
		wait 10
		call LootChest
		wait 20
		Follow:Set[TRUE]
		call follow
		wait 10
		call Move ${Actor["ancestral column"].X} ${Actor["ancestral column"].Y} ${Actor["ancestral column"].Z} 5 0 FALSE FALSE TRUE FALSE TRUE
		wait 20
		Actor["ancestral column"]:DoubleClick
		wait 50
		while ${Me.InCombat} || ${Me.IsHated}
			wait 5
		while ${Actor[ragefire](exists)}
			wait 5
	}
}
function Captain()
{
	if ${ISXOgre(exists)}
	{
		OgreBotAtom a_MoveToCampSpot all
		OgreBotAtom a_SetUpFor all Captain
		target Captain
		while ${Actor[Captain](exists)}
		{
			if ${Me.SubClass.Equal[inquisitor]} && ${Me.ToActor.IsDead} && ${Me.Ability["Immaculate Revival"].IsReady}
				Me.Ability["Immaculate Revival"]:Use
			;if ${CustomActor[deacon,radius,20](exists)} && !${GlobalOthers}
			;	target deacon
			elseif ${CustomActor[captain,radius,50](exists)} && !${GlobalOthers}
				target captain
			wait 2
		}
	}
	else
	{
		while ${Actor[Captain](exists)}
			wait 2
	}
}
function Neragul()
{
	while ${CustomActor[Neragul,radius,150](exists)} && !${CustomActor[Neragul,radius,150].IsDead}
	{
		if ${CustomActor[deacon,radius,15](exists)} && !${CustomActor[deacon,radius,15].IsDead} && !${GlobalOthers}
			target deacon
		elseif !${GlobalOthers}
			target Neragul
		if (${Target.Type.Equal[NPC]} || ${Target.Type.Equal[NamedNPC]})
			Face ${Target.X} ${Target.Z}
		elseif ${Target.Type.Equal[PC]} && (${Target.Target.Type.Equal[NPC]} || ${Target.Target.Type.Equal[NamedNPC]})
			Face ${Target.Target.X} ${Target.Target.Z}
		if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${LockMXN},${LockMYN},${LockMZN}]}>2
			call Move 1258.963135 34.580727 -530.014404 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
	call ExecuteQueued
	wait 2
	}
}
function Fherin()
{
	;need to make less dependant on ogre and make dps face mob
	variable int EastPlaneShifter
	variable int WestPlaneShifter
	variable float CNTempX=1730
	variable float CNTempY=117
	variable float CNTempZ=-139
	variable int FherinID
	
	if ${ISXOgre(exists)}
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_QueueCommand DoNotMove
	FherinID:Set[${Actor[Fherin].ID}]
	echo FherinID = ${FherinID}
	wait 2
	EastPlaneShifter:Set[${Actor[loc,1632.670044,-147.419998].ID}]
	echo EastPlanShifterID = ${EastPlaneShifter}
	wait 2
	WestPlaneShifter:Set[${Actor[loc,1822.570068,-147.629990].ID}]
	echo WestPlanShifterID = ${WestPlaneShifter}
	if ${GlobalOthers}
		wait 40
	wait 50
	while ${Actor[id,{$FherinID}](exists)} && !${Actor[id,{$FherinID}].IsDead}
	{
		;set Enchanter position
		if ${Me.Class.Equal[enchanter]}
		{
			CNTempX:Set[1730]
			CNTempY:Set[117]
			CNTempZ:Set[-115]
		}
		;target fherin
		if !${GlobalOthers} && ${Target.ID}!=${FherinID}
		{
			Actor[id,${FherinID}]:DoTarget
			eq2ex togglerangedattack
		}
		;move group into position
		if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
			call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
		;scouts and mages wait 5s
		if (${Me.Archetype.Equal[mage]} || ${Me.Archetype.Equal[scout]})
		{
			;turn off auto assist
			OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_assist FALSE
			wait 50
			;now move scouts to east planeshifter
			if ${Me.Archetype.Equal[Scout]}
			{
				CNTempX:Set[1705]
				CNTempY:Set[117]
				CNTempZ:Set[-138]
			}
		}
		;while loop to wait til east planeshifter dead and move to 1705 117 -125 when have curse
		while ${Actor[id,${EastPlaneShifter}](exists)} && (${Me.Archetype.Equal[mage]} || ${Me.Archetype.Equal[scout]})
		{
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
				call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			;targeting east planeshifter with scouts and mages
			Actor[id,${EastPlaneShifter}]:DoTarget
			Actor[id,${EastPlaneShifter}]:DoFace
			;checking cures and moving as needed 
			;echo checking curses for east planshifter
			while ${Me.Cursed}==-1
			{
				if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},1705,117,-120]}>2
					call Move 1705 117 -120 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
				wait 10
			}
			wait 2
			if ${Actor[corpse](exists)}
				relay ${RI_Var_String_RelayGroup} -noredirect Actor[id,${EastPlaneShifter}]:DoubleClick
		}
		;now move scouts to WestPlaneShifter
		if ${Me.Archetype.Equal[Scout]}
		{
			CNTempX:Set[1752]
			CNTempY:Set[117]
			CNTempZ:Set[-138]
		}
		;while loop to wait till fight is over and move to 1755 117 -125 when have curse
		while ${Actor[id,${WestPlaneShifter}](exists)} && (${Me.Archetype.Equal[mage]} || ${Me.Archetype.Equal[scout]})
		{
			if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},${CNTempX},${CNTempY},${CNTempZ}]}>2
				call Move ${CNTempX} ${CNTempY} ${CNTempZ} ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
			;targeting east planeshifter with scouts and mages
			Actor[id,${WestPlaneShifter}]:DoTarget
			Actor[id,${WestPlaneShifter}]:DoFace
			;checking cures and moving as needed 
			;echo checking curses for WestPlaneShifter
			while ${Me.Cursed}==-1
			{
				if ${Math.Distance[${Me.X},${Me.Y},${Me.Z},1752,117,-120]}>2
					call Move 1752 117 -120 ${Precision} 0 FALSE FALSE TRUE FALSE TRUE
				wait 10
			}
			wait 2
			if ${Actor[corpse](exists)}
				relay ${RI_Var_String_RelayGroup} -noredirect Actor[id,${WestPlaneShifter}]:DoubleClick
		}
		if ${Actor[corpse](exists)}
			relay ${RI_Var_String_RelayGroup} -noredirect Actor[id,${FherinID}]:DoubleClick
		waitframe
	}
	;turn on auto assist
	if (${Me.Archetype.Equal[mage]} || ${Me.Archetype.Equal[scout]})
		OgreBotAtom aExecuteAtom ${Me} a_UplinkControllerFunctionAutoType checkbox_settings_assist FALSE
	if ${Actor["ancestral column"](exists)}
	{
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_LetsGo all
		wait 10
		call LootChest
		wait 20
		Follow:Set[TRUE]
		call follow
		wait 10
		call Move ${Actor["ancestral column"].X} ${Actor["ancestral column"].Y} ${Actor["ancestral column"].Z} 5 0 FALSE FALSE TRUE FALSE TRUE
		wait 20
		Actor["ancestral column"]:DoubleClick
		wait 50
		while ${Me.InCombat} || ${Me.IsHated}
			wait 5
		while ${Actor[ragefire](exists)}
			wait 5
	}
	if !${GlobalOthers}
	{
		wait 10
		call Move ${Actor[Chest].X} ${Actor[Chest].Y} ${Actor[Chest].Z} 5 0 FALSE FALSE TRUE TRUE
		wait 10
		call LootChest
		wait 10
		if ${ISXOgre(exists)}
			relay "other ${RI_Var_String_RelayGroup}" -noredirect OgreBotAtom a_LetsGo all
		Follow:Set[TRUE]
		call follow
		wait 50
		relay ${RI_Var_String_RelayGroup} -noredirect OgreBotAtom a_QueueCommand EvacSpell
		wait 200
		if ${ISXOgre(exists)}
			relay "other ${RI_Var_String_RelayGroup}" -noredirect OgreBotAtom a_LetsGo all
		call follow
		wait 10
		if ${ISXOgre(exists)}
			relay "other ${RI_Var_String_RelayGroup}" -noredirect OgreBotAtom a_LetsGo all
		call follow
		wait 10
		call Move 189.19 17.02 275.25 2 0 FALSE FALSE TRUE FALSE TRUE
		wait 50
		relay ${RI_Var_String_RelayGroup} -noredirect Actor[center_door_1]:DoubleClick
		wait 10
		relay ${RI_Var_String_RelayGroup} -noredirect endscript runinstances
	}
}
function Welkus()
{
	echo welkus running
	variable bool WelkPos1=TRUE
	variable bool WelkPos2=FALSE
	variable int PosX=1730
	variable int PosZ=270
	variable int Precision1=2
	target Welkus
	while ${Actor[Welkus](exists)} && !${Actor[Welkus].IsDead}
	{
		if ${Me.SubClass.Equal[inquisitor]} && ${Me.ToActor.IsDead} && ${Me.Ability["Immaculate Revival"].IsReady}
			Me.Ability["Immaculate Revival"]:Use
		;1945,270 and 1910, 350 and  1730, 170 and 1690, 270     pos 1730 270 other pos 1910 , 270
		;wait until the strange portal appears
		while !${Actor[a strange portal](exists)} && ${Actor[Welkus](exists)}
		{
			if ${WelkPos1}
			{
				PosX:Set[1730]
				PosZ:Set[270]
			}
			else
			{
				PosX:Set[1910]
				PosZ:Set[270]
			}
			while ${Math.Distance[${Me.X},${Me.Z},${PosX},${PosZ}]}>${Precision1}
			{
				
				echo we are more than ${Precision1} away from ${PosX},${PosZ}
				move:Set[TRUE]
				;if ${Me.ToActor.Target(exists)}
				;	eq2execute target_none
				;face x,z position and press and hold forward key
				Face ${PosX} ${PosZ}
				press -hold ${ForwardKey}
				;check distance from my current x,y position vs the predetermined x,z positions
				;if smaller than the precision stop move
				if ${Math.Distance[${Me.X},${Me.Z},${PosX},${PosZ}]}<${Precision1}
				{
					move:Set[FALSE]	
				}
				;if stop button is pushed stop move
				elseif !${start}
				{
					move:Set[FALSE]
				}
				;execute queued commands
				if ${QueuedCommands}
				{
					ExecuteQueued
				}
				wait 2
			
				;if we are there release the forwardkey (stop move)
				if ${Math.Distance[${Me.X},${Me.Z},${PosX},${PosZ}]}<${Precision1}
					press -release ${ForwardKey}
			}
			;target Welkus
			wait 2
		}
		while ${Math.Distance[${Me.X},${Me.Z},${Actor[a strange portal].X},${Actor[a strange portal].Z}]}>${Precision1} && ${Actor[a strange portal](exists)}
		{
			echo we are more than ${Precision1} away from the strange portal
			move:Set[TRUE]
			;face x,z position and press and hold forward key
			if ${Math.Distance[${Me.X},${Me.Z},${Actor[a strange portal].X},${Actor[a strange portal].Z}]}>150
			{
				if ${Math.Distance[${Me.X},${Me.Z},1730,270]}>20
				{
					WelkPos1:Set[TRUE]
					WelkPos2:Set[FALSE]
				}
				else
				{
					WelkPos2:Set[TRUE]
					WelkPos1:Set[FALSE]
				}
				if ${WelkPos1}
				{
					PosX:Set[1730]
					PosZ:Set[270]
				}
				else
				{
					PosX:Set[1910]
					PosZ:Set[270]
				}
				while ${Math.Distance[${Me.X},${Me.Z},${PosX},${PosZ}]}>${Precision1}
				{
					echo we are more than ${Precision1} away from ${PosX},${PosZ}
					move:Set[TRUE]
					if ${Me.ToActor.Target(exists)}
						eq2execute target_none
					;face x,z position and press and hold forward key
					Face ${PosX} ${PosZ}
					press -hold ${ForwardKey}
					;check distance from my current x,y position vs the predetermined x,z positions
					;if smaller than the precision stop move
					if ${Math.Distance[${Me.X},${Me.Z},${PosX},${PosZ}]}<${Precision1}
					{
						move:Set[FALSE]	
					}
					;if stop button is pushed stop move
					elseif !${start}
					{
						move:Set[FALSE]
					}
					;execute queued commands
					if ${QueuedCommands}
					{
						ExecuteQueued
					}
					wait 2
				
					;if we are there release the forwardkey (stop move)
					if ${Math.Distance[${Me.X},${Me.Z},${PosX},${PosZ}]}<${Precision1}
						press -release ${ForwardKey}
				}
				wait 2
			}		
			Face ${Actor[a strange portal].X} ${Actor[a strange portal].Z}
			press -hold ${ForwardKey}
			;check distance from my current x,y position vs the predetermined x,z positions
			;if smaller than the precision stop move
			if ${Math.Distance[${Me.X},${Me.Z},${Actor[a strange portal].X},${Actor[a strange portal].Z}]}<${Precision1}
			{
				move:Set[FALSE]	
			}
			;if stop button is pushed stop move
			elseif !${start}
			{
				move:Set[FALSE]
			}
			;execute queued commands
			if ${QueuedCommands}
			{
				ExecuteQueued
			}
			wait 2
			;if we are there release the forwardkey (stop move)
			if ${Math.Distance[${Me.X},${Me.Z},${Actor[a strange portal].X},${Actor[a strange portal].Z}]}<${Precision1}
				press -release ${ForwardKey}
			target strange portal
		}
		wait 1
	}
	wait 10
	Actor[Welkus]:DoubleClick
	wait 10
	call LootChest
	wait 10
	Follow:Set[TRUE]
	call follow
	if ${Math.Distance[${Me.X},${Me.Z},1730,270]}>${Precision1}
		call Move 1820.069489 302.224440 270.623108 2 0 FALSE FALSE TRUE TRUE
}
;waypoints to move to for Raknag
;-60.399815 -77.761658 59.228947
;-62.127186 -77.780548 45.808964
;-67.409546 -77.753578 30.987982
;-76.165253 -77.796280 16.744701
;-76.114464 -77.804520 4.311768
;Raknag weaves a ring of blue


;Run them down, my pets!



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;; END OF TOV NAMED CODING ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
